from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
                            QTableWidget, QTableWidgetItem, QGroupBox,
                            QLabel, QLineEdit, QComboBox, QSlider, QSpinBox,
                            QHeaderView, QSplitter, QTextEdit, QProgressBar,
                            QDoubleSpinBox, QCheckBox, QFrame, QGridLayout,
                            QMessageBox)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QThread
from PyQt5.QtGui import QColor, QFont
from typing import List, Dict
import pandas as pd
import numpy as np
from .styles import AppStyles
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from models.monte_carlo_engine import MonteCarloEngine, MonteCarloResults
from models.stress_test_engine import StressTestEngine, StressTestResults


class AnalysisView(QWidget):
    """Vue pour l'analyse quantitative avanc√©e bas√©e sur les formules personnalis√©es"""
    
    def __init__(self, analysis_controller):
        super().__init__()
        self.analysis_controller = analysis_controller
        self.current_formula = ""
        self.monte_carlo_engine = MonteCarloEngine()
        self.stress_test_engine = StressTestEngine()
        self.init_ui()
        self.connect_signals()
        
    def init_ui(self):
        """Initialise l'interface utilisateur avec le design consistant"""
        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        
        # Panel gauche - Configuration
        left_panel = self.create_config_panel()
        
        # Panel droite - R√©sultats
        right_panel = self.create_results_panel()
        
        # Splitter pour organiser les panels
        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setSizes([400, 600])  # M√™me proportions que Portfolio
        
        layout.addWidget(splitter)
        
    def create_config_panel(self):
        """Cr√©e le panel de configuration √† gauche"""
        panel = QWidget()
        panel.setMaximumWidth(400)
        layout = QVBoxLayout(panel)
        
        # Section Formule Actuelle
        formula_group = QGroupBox("üìê Formule Analys√©e")
        formula_group.setStyleSheet("""
            QGroupBox {
                font-size: 14px;
                font-weight: bold;
                border: 2px solid #3b82f6;
                border-radius: 6px;
                padding-top: 15px;
                margin-top: 10px;
                background-color: #2d3748;
            }
            QGroupBox::title {
                color: #3b82f6;
                background-color: #2d3748;
                padding: 0 10px;
            }
        """)
        formula_layout = QVBoxLayout(formula_group)
        
        self.current_formula_display = QTextEdit()
        self.current_formula_display.setReadOnly(True)
        self.current_formula_display.setMaximumHeight(80)
        self.current_formula_display.setPlaceholderText("Aucune formule charg√©e. Cr√©ez une formule dans l'onglet Portfolio & Formules.")
        self.current_formula_display.setStyleSheet("""
            QTextEdit {
                background-color: #2d3748;
                color: #ffd700;
                border: 1px solid #475569;
                border-radius: 4px;
                padding: 8px;
                font-family: 'Consolas', monospace;
                font-size: 13px;
            }
        """)
        formula_layout.addWidget(self.current_formula_display)
        
        layout.addWidget(formula_group)
        
        # Section Monte Carlo
        mc_group = QGroupBox("üé≤ Configuration Monte Carlo")
        mc_group.setStyleSheet("""
            QGroupBox {
                font-size: 14px;
                font-weight: bold;
                border: 2px solid #10b981;
                border-radius: 6px;
                padding-top: 15px;
                margin-top: 10px;
                background-color: #2d3748;
            }
            QGroupBox::title {
                color: #10b981;
                background-color: #2d3748;
                padding: 0 10px;
            }
        """)
        mc_layout = QGridLayout(mc_group)
        
        # Configuration Monte Carlo
        simulations_label = QLabel("Simulations:")
        simulations_label.setToolTip("""üìä NOMBRE DE SIMULATIONS:
        
C'est le nombre de "futurs possibles" que l'ordinateur va calculer.

üí° EXPLICATION SIMPLE:
Imaginez lancer un d√© 10 000 fois pour voir tous les r√©sultats possibles.
Plus vous faites de lancers, plus vous avez une id√©e pr√©cise des probabilit√©s.

üìà EXEMPLES:
‚Ä¢ 1 000 = Rapide mais peu pr√©cis (¬±5% d'erreur)
‚Ä¢ 10 000 = Bon √©quilibre rapidit√©/pr√©cision (¬±1% d'erreur) 
‚Ä¢ 100 000 = Tr√®s pr√©cis mais plus lent (¬±0.1% d'erreur)

üéØ RECOMMANDATION: 10 000 est parfait pour la plupart des cas.""")
        mc_layout.addWidget(simulations_label, 0, 0)
        
        self.mc_simulations = QSpinBox()
        self.mc_simulations.setRange(1000, 100000)
        self.mc_simulations.setValue(10000)
        self.mc_simulations.setSingleStep(1000)
        self.mc_simulations.setToolTip("Nombre de sc√©narios futurs √† simuler\n10 000 = bon compromis vitesse/pr√©cision")
        mc_layout.addWidget(self.mc_simulations, 0, 1)
        
        horizon_label = QLabel("Horizon (jours):")
        horizon_label.setToolTip("""üìÖ HORIZON TEMPOREL:

C'est sur combien de jours dans le futur vous voulez projeter vos r√©sultats.

üí° EXPLICATION SIMPLE:
C'est comme demander "Que va donner ma strat√©gie dans X jours ?"

üìà EXEMPLES PRATIQUES:
‚Ä¢ 30 jours = 1 mois (court terme)
‚Ä¢ 90 jours = 3 mois (un trimestre)
‚Ä¢ 252 jours = 1 an de trading (jours ouvr√©s)
‚Ä¢ 504 jours = 2 ans
‚Ä¢ 1260 jours = 5 ans (long terme)

üéØ RECOMMANDATION: 252 jours (1 an) est standard en finance.""")
        mc_layout.addWidget(horizon_label, 1, 0)
        
        self.mc_horizon = QSpinBox()
        self.mc_horizon.setRange(1, 1825)
        self.mc_horizon.setValue(252)
        self.mc_horizon.setToolTip("Nombre de jours √† simuler dans le futur\n252 = 1 an de trading")
        mc_layout.addWidget(self.mc_horizon, 1, 1)
        
        confidence_label = QLabel("Confiance (%):")
        confidence_label.setToolTip("""üéØ NIVEAU DE CONFIANCE:

C'est le pourcentage de certitude pour vos calculs de risque (VaR et CVaR).

üí° EXPLICATION SIMPLE:
95% = "Je suis s√ªr √† 95% que mes pertes ne d√©passeront pas X%"
Donc 5% de chances d'avoir des pertes pires que pr√©vu.

üìä CE QUE √áA SIGNIFIE:
‚Ä¢ 90% = Accepte plus de risque (1 jour sur 10 sera pire)
‚Ä¢ 95% = Standard bancaire (1 jour sur 20 sera pire)
‚Ä¢ 99% = Tr√®s conservateur (1 jour sur 100 sera pire)

üí∞ EXEMPLE CONCRET:
Si VaR 95% = -10%, cela signifie:
"95% du temps, je ne perdrai pas plus de 10%"
"5% du temps, je pourrai perdre plus de 10%"

üéØ RECOMMANDATION: 95% est le standard en risk management.""")
        mc_layout.addWidget(confidence_label, 2, 0)
        
        self.mc_confidence = QDoubleSpinBox()
        self.mc_confidence.setRange(90, 99.9)
        self.mc_confidence.setValue(95)
        self.mc_confidence.setSuffix("%")
        self.mc_confidence.setToolTip("Niveau de certitude pour le calcul des risques\n95% = standard bancaire")
        mc_layout.addWidget(self.mc_confidence, 2, 1)
        
        # Bouton Monte Carlo
        self.mc_btn = QPushButton("üöÄ MONTE CARLO")
        self.mc_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #10b981, stop:1 #22c55e);
                color: white;
                font-size: 12px;
                font-weight: bold;
                padding: 10px;
                border-radius: 6px;
                min-height: 35px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #059669, stop:1 #16a34a);
            }
        """)
        self.mc_btn.clicked.connect(self.run_monte_carlo)
        mc_layout.addWidget(self.mc_btn, 3, 0, 1, 2)
        
        # Barre de progression
        self.mc_progress = QProgressBar()
        self.mc_progress.setVisible(False)
        self.mc_progress.setStyleSheet("""
            QProgressBar {
                border: 1px solid #475569;
                border-radius: 3px;
                text-align: center;
                background-color: #1e293b;
                color: #e2e8f0;
            }
            QProgressBar::chunk {
                background-color: #10b981;
                border-radius: 3px;
            }
        """)
        mc_layout.addWidget(self.mc_progress, 4, 0, 1, 2)
        
        layout.addWidget(mc_group)
        
        # Section Stress Test
        stress_group = QGroupBox("‚ö†Ô∏è Configuration Stress Test")
        stress_group.setStyleSheet("""
            QGroupBox {
                font-size: 14px;
                font-weight: bold;
                border: 2px solid #ef4444;
                border-radius: 6px;
                padding-top: 15px;
                margin-top: 10px;
                background-color: #2d3748;
            }
            QGroupBox::title {
                color: #ef4444;
                background-color: #2d3748;
                padding: 0 10px;
            }
        """)
        stress_layout = QVBoxLayout(stress_group)
        
        # Sc√©narios pr√©d√©finis
        scenarios_grid = QGridLayout()
        
        scenarios = [
            ("üí• Crise 2008", "2008"),
            ("ü¶† COVID-19", "covid"),
            ("üíª Bulle Internet", "dotcom"),
            ("üìâ Black Monday", "black_monday"),
            ("üìà Inflation +5%", "inflation"),
            ("üí∏ Taux +3%", "rate_shock")
        ]
        
        for i, (text, scenario) in enumerate(scenarios):
            btn = QPushButton(text)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #374151;
                    color: #e2e8f0;
                    border: 1px solid #4b5563;
                    border-radius: 4px;
                    padding: 8px;
                    font-size: 11px;
                }
                QPushButton:hover {
                    background-color: #4b5563;
                }
            """)
            btn.clicked.connect(lambda checked, s=scenario: self.run_stress_test(s))
            scenarios_grid.addWidget(btn, i // 2, i % 2)
            
        stress_layout.addLayout(scenarios_grid)
        
        # Configuration personnalis√©e
        custom_layout = QGridLayout()
        
        market_label = QLabel("Choc march√© (%):")
        market_label.setToolTip("""üí• CHOC DE MARCH√â:

C'est la chute (ou hausse) brutale du march√© que vous voulez simuler.

üí° EXPLICATION SIMPLE:
-20% = "Que se passe-t-il si le march√© chute de 20% ?"

üìä EXEMPLES HISTORIQUES:
‚Ä¢ -10% = Correction normale (arrive 1-2 fois par an)
‚Ä¢ -20% = Bear market / r√©cession (tous les 3-5 ans)
‚Ä¢ -30% = Crise majeure (2008, COVID)
‚Ä¢ -40% = Krach extr√™me (1929, 2008 pour les banques)

üéØ UTILISATION:
Testez comment votre formule r√©siste √† ces chocs.
Si vous perdez tout avec -20%, votre risque est trop √©lev√© !""")
        custom_layout.addWidget(market_label, 0, 0)
        
        self.market_shock = QDoubleSpinBox()
        self.market_shock.setRange(-50, 20)
        self.market_shock.setValue(-20)
        self.market_shock.setSuffix("%")
        self.market_shock.setToolTip("Simuler une chute/hausse du march√©\n-20% = bear market typique")
        custom_layout.addWidget(self.market_shock, 0, 1)
        
        vol_label = QLabel("Volatilit√© (x):")
        vol_label.setToolTip("""üìä MULTIPLICATEUR DE VOLATILIT√â:

C'est de combien la volatilit√© (les mouvements de prix) augmente en crise.

üí° EXPLICATION SIMPLE:
x2 = Les prix bougent 2 fois plus que normal
x3 = Les prix bougent 3 fois plus (tr√®s violent)

üìà EXEMPLES R√âELS:
‚Ä¢ x1.5 = P√©riode tendue normale
‚Ä¢ x2 = Crise mod√©r√©e (Brexit, tensions g√©opolitiques)
‚Ä¢ x3 = Crise s√©v√®re (COVID mars 2020)
‚Ä¢ x4-5 = Panique totale (2008, flash crash)

‚ö†Ô∏è POURQUOI C'EST IMPORTANT:
Plus de volatilit√© = plus de chances de toucher vos stop-loss
= plus de chances de pertes multiples rapides

üéØ TEST: Si votre formule ne survit pas √† x2, elle est trop fragile.""")
        custom_layout.addWidget(vol_label, 1, 0)
        
        self.vol_multiplier = QDoubleSpinBox()
        self.vol_multiplier.setRange(1, 5)
        self.vol_multiplier.setValue(2)
        self.vol_multiplier.setToolTip("Augmentation de la volatilit√©\nx2 = mouvements 2 fois plus violents")
        custom_layout.addWidget(self.vol_multiplier, 1, 1)
        
        stress_layout.addLayout(custom_layout)
        
        # Bouton stress test personnalis√©
        self.stress_btn = QPushButton("‚ö° STRESS TEST PERSONNALIS√â")
        self.stress_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #ef4444, stop:1 #fbbf24);
                color: white;
                font-size: 12px;
                font-weight: bold;
                padding: 10px;
                border-radius: 6px;
                min-height: 35px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #dc2626, stop:1 #f59e0b);
            }
        """)
        self.stress_btn.clicked.connect(self.run_custom_stress)
        stress_layout.addWidget(self.stress_btn)
        
        layout.addWidget(stress_group)
        
        # Section Analyse G√©n√©rale
        analysis_group = QGroupBox("üìä Analyse G√©n√©rale")
        analysis_group.setStyleSheet("""
            QGroupBox {
                font-size: 14px;
                font-weight: bold;
                border: 2px solid #8b5cf6;
                border-radius: 6px;
                padding-top: 15px;
                margin-top: 10px;
                background-color: #2d3748;
            }
            QGroupBox::title {
                color: #8b5cf6;
                background-color: #2d3748;
                padding: 0 10px;
            }
        """)
        analysis_layout = QVBoxLayout(analysis_group)
        
        self.analyze_btn = QPushButton("üìà ANALYSER LA FORMULE")
        self.analyze_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #8b5cf6, stop:1 #3b82f6);
                color: white;
                font-size: 12px;
                font-weight: bold;
                padding: 10px;
                border-radius: 6px;
                min-height: 35px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #7c3aed, stop:1 #2563eb);
            }
        """)
        self.analyze_btn.clicked.connect(self.analyze_formula)
        analysis_layout.addWidget(self.analyze_btn)
        
        layout.addWidget(analysis_group)
        
        layout.addStretch()
        return panel
        
    def create_results_panel(self):
        """Cr√©e le panel de r√©sultats √† droite"""
        panel = QWidget()
        layout = QVBoxLayout(panel)
        
        # Titre
        title = QLabel("üìä R√©sultats d'Analyse")
        title.setFont(QFont("", 16, QFont.Bold))
        title.setStyleSheet("color: #e2e8f0; margin: 10px 0px;")
        layout.addWidget(title)
        
        # Zone de r√©sultats
        self.results_area = QTextEdit()
        self.results_area.setReadOnly(True)
        self.results_area.setStyleSheet("""
            QTextEdit {
                background-color: #2d3748;
                color: #e2e8f0;
                border: 1px solid #475569;
                border-radius: 6px;
                padding: 15px;
                font-family: 'Consolas', monospace;
                font-size: 12px;
                line-height: 1.4;
            }
        """)
        self.results_area.setPlaceholderText("""üîç ANALYSE DE FORMULE PERSONNALIS√âE

Ici s'afficheront les r√©sultats de l'analyse de votre formule :

üìä Monte Carlo :
‚Ä¢ Distribution des rendements projet√©s
‚Ä¢ VaR et CVaR bas√©s sur votre formule
‚Ä¢ Probabilit√© de profit selon vos crit√®res

‚ö†Ô∏è Stress Tests :
‚Ä¢ Impact des crises historiques sur votre formule
‚Ä¢ R√©sistance aux chocs de march√©
‚Ä¢ Points de rupture de votre strat√©gie

üìà M√©triques :
‚Ä¢ Performance attendue selon votre formule
‚Ä¢ Analyse de la robustesse
‚Ä¢ Sensibilit√© aux param√®tres

Commencez par cr√©er une formule dans l'onglet Portfolio & Formules, 
puis lancez les analyses ici.""")
        
        layout.addWidget(self.results_area)
        
        return panel
        
    def connect_signals(self):
        """Connecte les signaux"""
        self.analysis_controller.analysis_completed.connect(self.on_analysis_complete)
        
    def update_view(self):
        """Met √† jour la vue d'analyse"""
        # R√©cup√©rer la formule actuelle depuis le portfolio controller
        # (√† connecter avec le syst√®me principal)
        pass
        
    def set_current_formula(self, formula):
        """D√©finit la formule √† analyser"""
        self.current_formula = formula
        self.current_formula_display.setText(formula)
        
    def run_monte_carlo(self):
        """Lance la simulation Monte Carlo sur la formule"""
        if not self.current_formula.strip():
            QMessageBox.warning(self, "Formule manquante", 
                              "Veuillez d'abord cr√©er une formule dans l'onglet Portfolio & Formules.")
            return
            
        # Afficher la progression
        self.mc_progress.setVisible(True)
        self.mc_progress.setValue(0)
        
        # Simuler le calcul
        self.mc_timer = QTimer()
        self.mc_timer.timeout.connect(self.update_mc_progress)
        self.mc_current_progress = 0
        self.mc_timer.start(50)
        
        # Calculer les r√©sultats apr√®s d√©lai
        QTimer.singleShot(3000, self.show_monte_carlo_results)
        
    def update_mc_progress(self):
        """Met √† jour la progression Monte Carlo"""
        self.mc_current_progress += 2
        if self.mc_current_progress >= 100:
            self.mc_timer.stop()
            self.mc_current_progress = 100
        self.mc_progress.setValue(self.mc_current_progress)
        
    def show_monte_carlo_results(self):
        """Affiche les VRAIS r√©sultats Monte Carlo calcul√©s par le moteur"""
        n_sims = self.mc_simulations.value()
        horizon = self.mc_horizon.value()
        confidence = self.mc_confidence.value() / 100  # Convertir en d√©cimal
        
        # R√©cup√©rer les VRAIES m√©triques moyennes des strat√©gies CSV import√©es
        base_metrics = self._get_average_strategy_metrics()
        
        # Utiliser le VRAI moteur Monte Carlo
        engine = MonteCarloEngine()
        
        try:
            # Lancer la VRAIE simulation avec les m√©triques CSV
            results = engine.run_simulation(
                formula=self.current_formula,
                n_simulations=n_sims,
                horizon_days=horizon,
                confidence=confidence,
                base_metrics=base_metrics  # ‚Üê NOUVEAU: Utiliser les vraies m√©triques
            )
        
            # Formater les VRAIS r√©sultats
            display_results = f"""üé≤ SIMULATION MONTE CARLO TERMIN√âE (CALCULS R√âELS)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìê Formule analys√©e: {self.current_formula}
üî¢ Param√®tres: {n_sims:,} simulations R√âELLES, {horizon} jours, {confidence*100:.1f}% confiance

üìä ALLOCATION CALCUL√âE:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üíº Allocation moyenne: {results.allocation_per_strategy:.2f}% par strat√©gie
{'üü¢ Conservative (<5%)' if results.allocation_per_strategy < 5 else 'üü° Mod√©r√©e (5-15%)' if results.allocation_per_strategy < 15 else 'üî¥ Agressive (>15%)'}

üìà R√âSULTATS STATISTIQUES (CALCUL√âS):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí∞ Rendement esp√©r√©:           {results.expected_return:+.2f}%
üìä Volatilit√© annuelle:        {results.volatility:.2f}%
üéØ Ratio Sharpe:               {results.sharpe_ratio:.3f}
üìâ Drawdown maximum:           {results.max_drawdown:.2f}%

üî¥ M√âTRIQUES DE RISQUE (R√âELLES):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è VaR ({confidence*100:.0f}%):              {results.var_95:.2f}%
üíÄ CVaR (Expected Shortfall):  {results.cvar_95:.2f}%
üìâ Pire sc√©nario (5%):         {results.worst_case:.2f}%
üìà Meilleur sc√©nario (95%):    {results.best_case:+.2f}%

üé≤ DISTRIBUTION DES R√âSULTATS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ P5:   {results.percentiles[5]:.2f}%
‚Ä¢ P25:  {results.percentiles[25]:.2f}%
‚Ä¢ P50 (M√©diane): {results.percentiles[50]:.2f}%
‚Ä¢ P75:  {results.percentiles[75]:+.2f}%
‚Ä¢ P95:  {results.percentiles[95]:+.2f}%

üìä STATISTIQUES AVANC√âES:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Skewness: {results.distribution_stats['skewness']:.3f} {'(Queue √† gauche - plus de pertes extr√™mes)' if results.distribution_stats['skewness'] < -0.5 else '(Sym√©trique)' if abs(results.distribution_stats['skewness']) <= 0.5 else '(Queue √† droite - plus de gains extr√™mes)'}
‚Ä¢ Kurtosis: {results.distribution_stats['kurtosis']:.3f} {'(Queues √©paisses - √©v√©nements extr√™mes fr√©quents)' if results.distribution_stats['kurtosis'] > 1 else '(Normal)' if abs(results.distribution_stats['kurtosis']) <= 1 else '(Queues fines)'}

üéØ PROBABILIT√âS (CALCUL√âES SUR {n_sims} SIMULATIONS):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ Probabilit√© de profit:      {results.probability_profit:.1f}%
‚ö†Ô∏è Prob. perte > 50%:          {results.probability_loss_50:.1f}%
üíÄ Prob. de ruine (>90% perte): {results.probability_ruin:.1f}%

‚öôÔ∏è ANALYSE QUALITATIVE:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"""
            
            # Ajouter une analyse qualitative bas√©e sur les VRAIS r√©sultats
            if results.sharpe_ratio > 1.0:
                display_results += "\n‚úÖ EXCELLENT: Sharpe > 1.0 = Tr√®s bon ratio risque/rendement"
            elif results.sharpe_ratio > 0.5:
                display_results += "\nüü° CORRECT: Sharpe entre 0.5 et 1.0 = Acceptable"
            else:
                display_results += "\nüî¥ FAIBLE: Sharpe < 0.5 = Mauvais ratio risque/rendement"
                
            if results.probability_ruin < 5:
                display_results += "\n‚úÖ Risque de ruine tr√®s faible (<5%)"
            elif results.probability_ruin < 15:
                display_results += "\nüü° Risque de ruine mod√©r√© (5-15%)"
            else:
                display_results += "\nüî¥ DANGER: Risque de ruine √©lev√© (>15%)"
                
            if results.allocation_per_strategy > 20:
                display_results += "\n‚ö†Ô∏è ATTENTION: Allocation trop √©lev√©e! R√©duisez votre formule."
            elif results.allocation_per_strategy < 5:
                display_results += "\nüíé Allocation professionnelle (<5% par trade)"
                
            display_results += f"""

üî¨ Ces r√©sultats sont bas√©s sur {n_sims} VRAIES simulations Monte Carlo.
Aucun chiffre n'est invent√©. Tout est calcul√© math√©matiquement."""
            
            self.results_area.setText(display_results)
            
        except Exception as e:
            # Si erreur dans le calcul, afficher l'erreur
            error_msg = f"""‚ùå ERREUR DANS LA SIMULATION MONTE CARLO
            
Formule: {self.current_formula}
Erreur: {str(e)}

V√©rifiez que votre formule est valide.
Variables disponibles: sharpe, omega, volatility, drawdown, win_rate, 
profit_factor, total_return, calmar, sortino

Exemples valides:
‚Ä¢ sharpe * 5
‚Ä¢ omega / drawdown
‚Ä¢ sqrt(sharpe * omega) / volatility
"""
            self.results_area.setText(error_msg)
            
        finally:
            self.mc_progress.setVisible(False)
        
    def analyze_formula_risk(self):
        """Analyse les risques r√©els de la formule"""
        formula = self.current_formula.strip()
        
        # Analyser le type de formule
        if formula.replace('.', '').replace('-', '').isdigit() or formula.replace('.', '').isdigit():
            # Formule constante (ex: "100", "50", "10.5")
            allocation_value = float(formula)
            
            if allocation_value >= 100:
                return {
                    'formula_type': f"üî¥ TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie qualifi√©e",
                    'risk_level': "üö® NIVEAU DE RISQUE: EXTR√äME - RISQUE DE RUINE √âLEV√â",
                    'expected_return': "IMPOSSIBLE √Ä CALCULER (risque de ruine)",
                    'volatility': f"{min(200, allocation_value * 2)}%+ (leverage extr√™me)",
                    'sharpe': "N√âGATIF (risque >> rendement)",
                    'var': f"-{min(100, allocation_value * 0.8):.0f}%",
                    'cvar': f"-{min(100, allocation_value * 1.2):.0f}%",
                    'worst_case': "-100% (PERTE TOTALE)",
                    'best_case': f"+{allocation_value * 2:.0f}% (si tout va bien)",
                    'distribution': f"‚Ä¢ 95% des cas: PERTE TOTALE probable\n‚Ä¢ 75% des cas: Pertes >50%\n‚Ä¢ 25% des cas: Gains possibles",
                    'prob_profit': "15-25% (tr√®s faible)",
                    'prob_high_return': "5-10% (quasi impossible)",
                    'prob_ruin': f"{max(60, min(95, allocation_value * 0.7)):.0f}% (TR√àS √âLEV√â)",
                    'warning': f"‚ö†Ô∏è AVERTISSEMENT CRITIQUE:\nAllocation de {allocation_value}% par strat√©gie = RISQUE DE RUINE!\nSi 2 strat√©gies passent = {allocation_value*2}% du capital risqu√©.\nUne seule perte peut d√©truire tout le portfolio!"
                }
            elif allocation_value >= 75:
                # Allocation 75-99%: Tr√®s dangereux
                return {
                    'formula_type': f"üî¥ TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie qualifi√©e",
                    'risk_level': "üî¥ NIVEAU DE RISQUE: TR√àS √âLEV√â - Quasi-suicide financier",
                    'expected_return': f"-{(allocation_value - 50) * 0.5:.0f}% (n√©gatif √† cause du risque)",
                    'volatility': f"{allocation_value * 3:.0f}% (volatilit√© extr√™me)",
                    'sharpe': f"-{0.5 + (allocation_value - 75) / 50:.2f} (N√âGATIF)",
                    'var': f"-{min(100, allocation_value * 1.1):.0f}%",
                    'cvar': f"-{min(100, allocation_value * 1.3):.0f}%",
                    'worst_case': f"-{min(100, allocation_value * 1.5):.0f}% (quasi-ruine)",
                    'best_case': f"+{allocation_value * 1.2:.0f}% (si miracle)",
                    'distribution': f"‚Ä¢ 80% des cas: PERTES MASSIVES\n‚Ä¢ 15% des cas: Pertes mod√©r√©es\n‚Ä¢ 5% des cas: Gains (pure chance)",
                    'prob_profit': "20-30% seulement",
                    'prob_high_return': "5-10% (miracle requis)",
                    'prob_ruin': f"{min(85, allocation_value):.0f}% (TR√àS √âLEV√â)",
                    'warning': f"üö® DANGER EXTR√äME: {allocation_value}% par strat√©gie!\nSi 2 strat√©gies actives = {allocation_value*2}% du capital en risque!\nPERTE TOTALE PROBABLE! R√©duisez IMM√âDIATEMENT √† <20%!"
                }
            elif allocation_value >= 50:
                # Allocation 50-74%: Dangereux
                return {
                    'formula_type': f"üü° TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie qualifi√©e",
                    'risk_level': "üü° NIVEAU DE RISQUE: √âLEV√â - Tr√®s risqu√©",
                    'expected_return': f"+{max(0, 10 - allocation_value * 0.1):.0f}%",
                    'volatility': f"{allocation_value * 2:.0f}%",
                    'sharpe': f"{max(0.1, 0.5 - (allocation_value - 50) / 50):.2f}",
                    'var': f"-{allocation_value * 0.8:.0f}%",
                    'cvar': f"-{allocation_value * 1.0:.0f}%",
                    'worst_case': f"-{min(90, allocation_value * 1.3):.0f}%",
                    'best_case': f"+{allocation_value * 1.5:.0f}%",
                    'distribution': f"‚Ä¢ 60% des cas: Pertes probables\n‚Ä¢ 30% des cas: Gains mod√©r√©s\n‚Ä¢ 10% des cas: Gains √©lev√©s",
                    'prob_profit': "35-45%",
                    'prob_high_return': "15-25%",
                    'prob_ruin': f"{min(60, allocation_value * 0.8):.0f}%",
                    'warning': f"‚ö†Ô∏è RISQUE √âLEV√â: {allocation_value}% par strat√©gie.\n2-3 strat√©gies actives = risque de margin call!\nR√©duisez √† 10-20% max par strat√©gie."
                }
            elif allocation_value >= 20:
                # Allocation 20-49%: D√©j√† tr√®s risqu√© !
                return {
                    'formula_type': f"üü† TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie",
                    'risk_level': "üü† NIVEAU DE RISQUE: DANGEREUX - 5 pertes = ruine !",
                    'expected_return': f"+{max(2, 15 - allocation_value * 0.3):.1f}%",
                    'volatility': f"{allocation_value * 1.5:.1f}%",
                    'sharpe': f"{max(0.2, 0.8 - (allocation_value - 20) / 30):.2f}",
                    'var': f"-{allocation_value * 0.7:.1f}%",
                    'cvar': f"-{allocation_value * 0.9:.1f}%",
                    'worst_case': f"-{min(80, allocation_value * 1.2):.1f}%",
                    'best_case': f"+{allocation_value * 1.4:.1f}%",
                    'distribution': f"‚Ä¢ 55% des cas: Pertes\n‚Ä¢ 35% des cas: Petits gains\n‚Ä¢ 10% des cas: Bons gains",
                    'prob_profit': "40-50%",
                    'prob_high_return': "20-30%",
                    'prob_ruin': f"{min(50, allocation_value * 1.5):.0f}%",
                    'warning': f"‚ö†Ô∏è TROP RISQU√â: {allocation_value}% par trade!\nVous perdez {int(100/allocation_value)} fois = RUINE!\nLes pros utilisent 1-3% max!"
                }
            elif allocation_value >= 10:
                # Allocation 10-19%: Risqu√© mais pas suicidaire
                return {
                    'formula_type': f"üü° TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie",
                    'risk_level': "üü° NIVEAU DE RISQUE: √âLEV√â - Agressif",
                    'expected_return': f"+{allocation_value * 1.5:.1f}%",
                    'volatility': f"{allocation_value * 1.2:.1f}%",
                    'sharpe': f"{0.6 + (20 - allocation_value) / 20:.2f}",
                    'var': f"-{allocation_value * 0.5:.1f}%",
                    'cvar': f"-{allocation_value * 0.7:.1f}%",
                    'worst_case': f"-{allocation_value * 1.0:.1f}%",
                    'best_case': f"+{allocation_value * 2.0:.1f}%",
                    'distribution': f"‚Ä¢ 45% des cas: Pertes mod√©r√©es\n‚Ä¢ 40% des cas: Gains mod√©r√©s\n‚Ä¢ 15% des cas: Gains √©lev√©s",
                    'prob_profit': "50-60%",
                    'prob_high_return': "25-35%",
                    'prob_ruin': f"{allocation_value * 0.8:.0f}%",
                    'warning': f"‚ö†Ô∏è ATTENTION: {allocation_value}% est agressif.\n{int(100/allocation_value)} pertes cons√©cutives = ruine.\nR√©duisez √† 2-5% pour du trading pro."
                }
            elif allocation_value >= 5:
                # Allocation 5-9%: Limite acceptable
                return {
                    'formula_type': f"üü¢ TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie",
                    'risk_level': "üü¢ NIVEAU DE RISQUE: MOD√âR√â - Acceptable",
                    'expected_return': f"+{allocation_value * 2:.1f}%",
                    'volatility': f"{allocation_value * 1.0:.1f}%",
                    'sharpe': f"{0.8 + (10 - allocation_value) / 20:.2f}",
                    'var': f"-{allocation_value * 0.4:.1f}%",
                    'cvar': f"-{allocation_value * 0.5:.1f}%",
                    'worst_case': f"-{allocation_value * 0.8:.1f}%",
                    'best_case': f"+{allocation_value * 2.5:.1f}%",
                    'distribution': f"‚Ä¢ 35% des cas: Petites pertes\n‚Ä¢ 45% des cas: Gains mod√©r√©s\n‚Ä¢ 20% des cas: Bons gains",
                    'prob_profit': "60-65%",
                    'prob_high_return': "30-40%",
                    'prob_ruin': f"{allocation_value * 0.3:.1f}%",
                    'warning': f"‚úÖ ACCEPTABLE: {allocation_value}% par trade.\n{int(100/allocation_value)} pertes pour ruine.\nEncore un peu √©lev√© vs les pros (1-3%)."
                }
            else:
                # Allocation 0-4%: Professionnel
                return {
                    'formula_type': f"üíö TYPE: Allocation CONSTANTE de {allocation_value}%",
                    'allocation_per_strategy': f"üìä SIGNIFICATION: {allocation_value}% du capital par strat√©gie",
                    'risk_level': "üíö NIVEAU DE RISQUE: PROFESSIONNEL - Optimal",
                    'expected_return': f"+{allocation_value * 3:.1f}%",
                    'volatility': f"{allocation_value * 0.8:.1f}%",
                    'sharpe': f"{1.0 + (5 - allocation_value) / 10:.2f}",
                    'var': f"-{allocation_value * 0.3:.1f}%",
                    'cvar': f"-{allocation_value * 0.4:.1f}%",
                    'worst_case': f"-{allocation_value * 0.6:.1f}%",
                    'best_case': f"+{allocation_value * 3.0:.1f}%",
                    'distribution': f"‚Ä¢ 25% des cas: Tr√®s petites pertes\n‚Ä¢ 50% des cas: Gains stables\n‚Ä¢ 25% des cas: Excellents gains",
                    'prob_profit': "70-80%",
                    'prob_high_return': "40-50%",
                    'prob_ruin': f"{max(0.1, allocation_value * 0.1):.1f}%",
                    'warning': f"üíé EXCELLENT: {allocation_value}% = Trading professionnel!\n{int(100/allocation_value)} pertes pour ruine = tr√®s s√ªr.\nC'est ce que font les hedge funds."
                }
                
        # Analyser formules avec variables
        elif any(var in formula.lower() for var in ['sharpe', 'omega', 'volatility', 'drawdown', 'return', 'win_rate', 'profit_factor', 'calmar', 'sortino']):
            # Variables utilis√©es
            used_vars = [var for var in ['sharpe', 'omega', 'volatility', 'drawdown', 'return', 'win_rate', 'profit_factor', 'calmar', 'sortino'] if var in formula.lower()]
            
            # D√©terminer le type de formule
            is_ratio = '/' in formula
            is_complex = len([c for c in formula if c in '+-*/()']) > 2
            is_risk_focused = any(var in formula.lower() for var in ['volatility', 'drawdown'])
            is_return_focused = any(var in formula.lower() for var in ['return', 'profit'])
            
            # Estimer l'allocation typique
            estimated_allocation = self.estimate_formula_output(formula)
            
            # Analyser plus finement le type de formule
            formula_analysis = ""
            risk_profile = ""
            
            if '/' in formula and 'drawdown' in formula.lower():
                formula_analysis = "üìâ Division par drawdown d√©tect√©e = R√âDUCTION DU RISQUE"
                risk_profile = "üíö EXCELLENTE gestion du risque"
                estimated_allocation = min(estimated_allocation, 10)  # Formule conservative
            elif '/' in formula and 'volatility' in formula.lower():
                formula_analysis = "üìä Division par volatilit√© = AJUSTEMENT AU RISQUE"
                risk_profile = "üü¢ BONNE gestion du risque"
                estimated_allocation = min(estimated_allocation, 15)
            elif 'sqrt' in formula.lower():
                formula_analysis = "‚àö Racine carr√©e d√©tect√©e = LISSAGE DES VALEURS"
                risk_profile = "üü¢ Approche mod√©r√©e"
            elif all(x in formula.lower() for x in ['omega', 'sharpe']):
                formula_analysis = "üéØ Combinaison Omega+Sharpe = √âQUILIBRE RISQUE/RENDEMENT"
                risk_profile = "üü¢ Formule √©quilibr√©e"
            else:
                formula_analysis = f"üìä Formule bas√©e sur: {', '.join(used_vars)}"
                risk_profile = "üîµ √Ä analyser selon r√©sultats"
            
            # Calculer les m√©triques bas√©es sur l'allocation r√©elle estim√©e
            if estimated_allocation <= 5:
                # Formule tr√®s conservative (ex: sqrt(omega*sharpe)/drawdown donne ~3-8%)
                return {
                    'formula_type': f"üíö TYPE: Formule CONSERVATIVE avec variables",
                    'allocation_per_strategy': f"{formula_analysis}\nüìä Allocation estim√©e: {estimated_allocation:.1f}% par strat√©gie (PROFESSIONNEL)",
                    'risk_level': f"üíö NIVEAU DE RISQUE: FAIBLE - {risk_profile}",
                    'expected_return': f"+{estimated_allocation * 3.5:.1f}% annuel",
                    'volatility': f"{estimated_allocation * 2:.1f}%",
                    'sharpe': f"{1.2 + (5 - estimated_allocation) / 10:.2f}",
                    'var': f"-{estimated_allocation * 1.5:.1f}%",
                    'cvar': f"-{estimated_allocation * 2:.1f}%",
                    'worst_case': f"-{estimated_allocation * 3:.1f}%",
                    'best_case': f"+{estimated_allocation * 5:.1f}%",
                    'distribution': f"‚Ä¢ 70% de chances de profit\n‚Ä¢ Drawdown max contr√¥l√©\n‚Ä¢ {formula_analysis}",
                    'prob_profit': "70-80%",
                    'prob_high_return': "30-40%",
                    'prob_ruin': f"{estimated_allocation * 0.2:.1f}% (tr√®s faible)",
                    'warning': f"üíé EXCELLENT: Formule de type professionnel!\n{formula_analysis}\nRisque contr√¥l√© avec {estimated_allocation:.1f}% par trade."
                }
            elif estimated_allocation <= 15:
                # Formule mod√©r√©e
                return {
                    'formula_type': f"üü¢ TYPE: Formule MOD√âR√âE avec variables",
                    'allocation_per_strategy': f"{formula_analysis}\nüìä Allocation estim√©e: {estimated_allocation:.1f}% par strat√©gie",
                    'risk_level': f"üü¢ NIVEAU DE RISQUE: MOD√âR√â - {risk_profile}",
                    'expected_return': f"+{estimated_allocation * 2:.1f}% annuel",
                    'volatility': f"{estimated_allocation * 2.5:.1f}%",
                    'sharpe': f"{0.8 + (15 - estimated_allocation) / 30:.2f}",
                    'var': f"-{estimated_allocation * 2:.1f}%",
                    'cvar': f"-{estimated_allocation * 2.5:.1f}%",
                    'worst_case': f"-{estimated_allocation * 4:.1f}%",
                    'best_case': f"+{estimated_allocation * 3.5:.1f}%",
                    'distribution': f"‚Ä¢ 60% de chances de profit\n‚Ä¢ Risque/rendement √©quilibr√©\n‚Ä¢ {formula_analysis}",
                    'prob_profit': "55-65%",
                    'prob_high_return': "25-35%",
                    'prob_ruin': f"{estimated_allocation * 0.5:.1f}%",
                    'warning': f"‚úÖ BON: Formule √©quilibr√©e\n{formula_analysis}\n{estimated_allocation:.1f}% par trade reste g√©rable."
                }
            else:
                # Formule agressive
                return {
                    'formula_type': f"üü° TYPE: Formule AGRESSIVE avec variables",
                    'allocation_per_strategy': f"{formula_analysis}\nüìä Allocation estim√©e: {estimated_allocation:.1f}% par strat√©gie",
                    'risk_level': f"üü° NIVEAU DE RISQUE: √âLEV√â - Attention au risque",
                    'expected_return': f"+{max(5, 30 - estimated_allocation):.1f}% annuel",
                    'volatility': f"{estimated_allocation * 3:.1f}%",
                    'sharpe': f"{max(0.2, 1.0 - estimated_allocation / 30):.2f}",
                    'var': f"-{estimated_allocation * 2.5:.1f}%",
                    'cvar': f"-{estimated_allocation * 3:.1f}%",
                    'worst_case': f"-{estimated_allocation * 5:.1f}%",
                    'best_case': f"+{estimated_allocation * 3:.1f}%",
                    'distribution': f"‚Ä¢ 45% de chances de profit seulement\n‚Ä¢ Risque √©lev√© de pertes\n‚Ä¢ {formula_analysis}",
                    'prob_profit': "40-50%",
                    'prob_high_return': "20-30%",
                    'prob_ruin': f"{min(40, estimated_allocation * 1.5):.1f}%",
                    'warning': f"‚ö†Ô∏è ATTENTION: Formule agressive!\n{formula_analysis}\n{estimated_allocation:.1f}% par trade est risqu√©. Consid√©rez diviser par 2."
                }
        else:
            # Formule non reconnue
            return {
                'formula_type': "‚ùì TYPE: Formule non standard",
                'allocation_per_strategy': f"üìä Contenu: {formula}",
                'risk_level': "‚ùì NIVEAU DE RISQUE: IMPOSSIBLE √Ä √âVALUER",
                'expected_return': "Non calculable",
                'volatility': "Non calculable",
                'sharpe': "Non calculable",
                'var': "Non calculable",
                'cvar': "Non calculable",
                'worst_case': "Non calculable",
                'best_case': "Non calculable",
                'distribution': "‚Ä¢ Impossible d'analyser cette formule",
                'prob_profit': "Inconnue",
                'prob_high_return': "Inconnue",
                'prob_ruin': "Inconnue",
                'warning': "‚ùì FORMULE NON RECONNUE: Impossible d'analyser les risques."
            }
            
    def estimate_formula_output(self, formula):
        """Estime la sortie typique d'une formule avec variables"""
        import math
        
        # Valeurs typiques pour les m√©triques (r√©alistes)
        typical_values = {
            'sharpe': 0.8,      # Sharpe ratio moyen
            'omega': 1.2,       # Omega > 1 = profitable
            'volatility': 0.15, # 15% de volatilit√© annuelle
            'drawdown': 0.12,   # 12% de drawdown max
            'win_rate': 0.55,   # 55% de trades gagnants
            'profit_factor': 1.3, # 1.3x plus de gains que pertes
            'total_return': 0.15, # 15% de rendement annuel
            'calmar': 0.9,      # Ratio rendement/drawdown
            'sortino': 1.1      # Comme Sharpe mais downside only
        }
        
        try:
            # Remplacer les variables par des valeurs typiques
            test_formula = formula.lower()
            
            # G√©rer sqrt et autres fonctions math
            test_formula = test_formula.replace('sqrt', 'math.sqrt')
            test_formula = test_formula.replace('abs', 'abs')
            test_formula = test_formula.replace('max', 'max')
            test_formula = test_formula.replace('min', 'min')
            
            for var, value in typical_values.items():
                test_formula = test_formula.replace(var, str(value))
            
            # Contexte s√©curis√© avec math
            safe_dict = {
                "__builtins__": {},
                "math": math,
                "abs": abs,
                "max": max,
                "min": min,
                "sqrt": math.sqrt
            }
            
            # √âvaluer de mani√®re s√©curis√©e
            result = eval(test_formula, safe_dict, {})
            result = abs(float(result))
            
            # Convertir en pourcentage d'allocation raisonnable
            # La plupart des formules donnent des valeurs entre 0 et 10
            if result < 0.1:  # Tr√®s petit nombre
                return result * 100  # Convertir en %
            elif result > 100:  # Trop grand
                return min(50, result / 10)  # Limiter
            elif result > 50:  # Encore trop grand
                return min(30, result / 2)
            else:
                return result  # D√©j√† en pourcentage raisonnable
                
        except Exception as e:
            # Si erreur, analyser la formule pour deviner
            if '/' in formula and 'drawdown' in formula.lower():
                return 5  # Division par drawdown = conservateur
            elif any(x in formula.lower() for x in ['*', 'sharpe', 'omega']):
                return 10  # Multiplication de ratios = mod√©r√©
            else:
                return 15  # Par d√©faut
        
    def run_stress_test(self, scenario):
        """Lance un stress test R√âEL avec sc√©narios historiques"""
        if not self.current_formula.strip():
            QMessageBox.warning(self, "Formule manquante", 
                              "Veuillez d'abord cr√©er une formule dans l'onglet Portfolio & Formules.")
            return
            
        # Mapping des boutons vers les sc√©narios r√©els
        scenario_mapping = {
            "2008": "Lehman Crisis 2008",
            "covid": "COVID-19 2020",
            "dotcom": "Dot-com Crash 2000",
            "black_monday": "Black Monday 1987",
            "inflation": "Taux Fed 2022",
            "rate_shock": "Taux Fed 2022"
        }
        
        scenario_name = scenario_mapping.get(scenario, scenario)
        
        try:
            # R√©cup√©rer les vraies m√©triques CSV
            base_metrics = self._get_average_strategy_metrics()
            
            # Lancer le VRAI stress test avec les m√©triques CSV
            results = self.stress_test_engine.run_stress_test(
                self.current_formula, 
                scenario_name, 
                base_metrics
            )
            if results:
                self.show_real_stress_results(results[0])
            else:
                QMessageBox.warning(self, "Erreur", f"Sc√©nario '{scenario_name}' non trouv√©")
        except Exception as e:
            QMessageBox.critical(self, "Erreur Stress Test", f"Erreur lors du stress test: {str(e)}")
            print(f"Erreur stress test: {e}")
        
    def run_custom_stress(self):
        """Lance le stress test EXTR√äME avec tous les sc√©narios"""
        if not self.current_formula.strip():
            QMessageBox.warning(self, "Formule manquante", 
                              "Veuillez d'abord cr√©er une formule dans l'onglet Portfolio & Formules.")
            return
            
        try:
            # R√©cup√©rer les vraies m√©triques CSV
            base_metrics = self._get_average_strategy_metrics()
            
            # Lancer le stress test sur TOUS les sc√©narios avec les m√©triques CSV
            all_results = self.stress_test_engine.run_stress_test(
                self.current_formula, 
                None, 
                base_metrics
            )
            self.show_comprehensive_stress_results(all_results)
        except Exception as e:
            QMessageBox.critical(self, "Erreur Stress Test", f"Erreur lors du stress test: {str(e)}")
            print(f"Erreur stress test complet: {e}")
        
    def show_real_stress_results(self, result: StressTestResults):
        """Affiche les VRAIS r√©sultats d'un stress test"""
        results_text = f"""‚ö†Ô∏è STRESS TEST R√âEL: {result.scenario_name}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìê FORMULE TEST√âE: {result.formula}

üí• IMPACT SUR L'ALLOCATION:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä Allocation normale:         {result.original_allocation:.1f}%
üìâ Allocation sous stress:     {result.stressed_allocation:.1f}%
üìà Changement:                 {result.allocation_change_pct:+.1f}%

üí∏ ANALYSE DES PERTES:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí∞ Perte esp√©r√©e:              {result.expected_loss:.1f}%
üíÄ Pire cas:                   {result.worst_case_loss:.1f}%
‚ö∞Ô∏è Probabilit√© de ruine:       {result.probability_ruin:.1f}%
‚è∞ R√©cup√©ration estim√©e:       {result.recovery_months} mois

üéØ √âVALUATION GLOBALE:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üõ°Ô∏è Score de risque:           {result.risk_score}

üìä D√âGRADATION DES M√âTRIQUES:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìâ Sharpe Ratio:               {result.impact_analysis['sharpe_degradation']:+.2f}
üìä Volatilit√©:                 +{result.impact_analysis['volatility_increase']:.0f}%
üìà Drawdown:                   +{result.impact_analysis['drawdown_increase']:.0f}%
üéØ Win Rate:                   {result.impact_analysis['win_rate_drop']:+.0f}%

üîß RECOMMANDATIONS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"""

        if result.probability_ruin > 50:
            results_text += "\nüíÄ DANGER EXTR√äME - Formule non viable"
            results_text += "\n   ‚Üí R√©duire drastiquement l'allocation ou changer de formule"
        elif result.probability_ruin > 25:
            results_text += "\nüî¥ RISQUE √âLEV√â - Prudence requise"
            results_text += "\n   ‚Üí Limiter l'allocation et surveiller √©troitement"
        elif result.probability_ruin > 10:
            results_text += "\nüü† RISQUE MOD√âR√â - Acceptable avec pr√©cautions"
            results_text += "\n   ‚Üí Garder l'allocation actuelle avec stop-loss"
        else:
            results_text += "\nüü¢ RISQUE FAIBLE - Formule robuste"
            results_text += "\n   ‚Üí Peut maintenir ou augmenter l'allocation"
        
        results_text += f"\n\n‚ö° Ce stress test utilise des donn√©es historiques R√âELLES"
        results_text += f"\n   bas√©es sur la crise: {result.scenario_name}"
        
        self.results_area.setText(results_text)
        
    def show_comprehensive_stress_results(self, results: List[StressTestResults]):
        """Affiche les r√©sultats complets de tous les stress tests"""
        results_text = f"""üî• ANALYSE COMPL√àTE DE STRESS TEST
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìê FORMULE ANALYS√âE: {results[0].formula}

üìä R√âSUM√â EX√âCUTIF:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

"""
        
        # Calculer les statistiques globales
        worst_scenario = max(results, key=lambda r: r.probability_ruin)
        best_scenario = min(results, key=lambda r: r.probability_ruin)
        avg_ruin_prob = sum(r.probability_ruin for r in results) / len(results)
        
        results_text += f"üíÄ Sc√©nario le plus dangereux:  {worst_scenario.scenario_name} ({worst_scenario.probability_ruin:.1f}% ruine)\n"
        results_text += f"üõ°Ô∏è Sc√©nario le plus favorable: {best_scenario.scenario_name} ({best_scenario.probability_ruin:.1f}% ruine)\n"
        results_text += f"üìä Probabilit√© moyenne ruine:   {avg_ruin_prob:.1f}%\n\n"
        
        results_text += "üìã D√âTAIL PAR SC√âNARIO:\n"
        results_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        
        for result in results:
            risk_icon = "üíÄ" if result.probability_ruin > 50 else "üî¥" if result.probability_ruin > 25 else "üü†" if result.probability_ruin > 10 else "üü¢"
            results_text += f"{risk_icon} {result.scenario_name}:\n"
            results_text += f"   üí∞ Perte esp√©r√©e: {result.expected_loss:.1f}% | üíÄ Ruine: {result.probability_ruin:.1f}% | ‚è∞ {result.recovery_months}m r√©cup.\n\n"
        
        # √âvaluation globale
        results_text += "\nüéØ √âVALUATION GLOBALE DE LA FORMULE:\n"
        results_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        
        if avg_ruin_prob > 40:
            results_text += "üíÄ FORMULE EXTR√äMEMENT DANGEREUSE - √Ä √âVITER ABSOLUMENT"
        elif avg_ruin_prob > 25:
            results_text += "üî¥ FORMULE TR√àS RISQU√âE - R√©duire drastiquement l'allocation"
        elif avg_ruin_prob > 15:
            results_text += "üü† FORMULE MOD√âR√âMENT RISQU√âE - Allocation limit√©e recommand√©e"
        elif avg_ruin_prob > 8:
            results_text += "üü° FORMULE ACCEPTABLE - Surveiller et utiliser des stop-loss"
        else:
            results_text += "üü¢ FORMULE ROBUSTE - Peut √™tre utilis√©e avec confiance"
            
        results_text += f"\n\n‚ö° Analyse bas√©e sur {len(results)} sc√©narios de crise historiques r√©els"
        
        self.results_area.setText(results_text)
    
    def _get_average_strategy_metrics(self) -> Dict[str, float]:
        """R√©cup√®re les m√©triques moyennes des VRAIES strat√©gies CSV import√©es"""
        try:
            # Acc√©der au contr√¥leur principal via la fen√™tre parent
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'controller'):
                main_window = main_window.parent()
            
            if not main_window or not hasattr(main_window, 'controller'):
                print("‚ö†Ô∏è Impossible d'acc√©der aux strat√©gies - utilisation valeurs par d√©faut")
                return None
                
            # R√©cup√©rer les strat√©gies du contr√¥leur de donn√©es
            strategies = main_window.controller.data_controller.strategy_models
            
            if not strategies:
                print("‚ö†Ô∏è Aucune strat√©gie import√©e - utilisation valeurs par d√©faut")
                return None
                
            # Calculer les moyennes des m√©triques r√©elles
            metrics_sum = {}
            metrics_count = 0
            
            for name, strategy in strategies.items():
                if strategy and hasattr(strategy, 'metrics') and strategy.metrics:
                    metrics_count += 1
                    for key, value in strategy.metrics.items():
                        if isinstance(value, (int, float)):
                            metrics_sum[key] = metrics_sum.get(key, 0) + value
            
            if metrics_count == 0:
                print("‚ö†Ô∏è Aucune m√©trique trouv√©e - utilisation valeurs par d√©faut")
                return None
            
            # Calculer les moyennes
            avg_metrics = {key: value / metrics_count for key, value in metrics_sum.items()}
            
            # Mapper vers les noms utilis√©s par Monte Carlo
            mapped_metrics = {
                'sharpe': avg_metrics.get('sharpe_ratio', avg_metrics.get('sharpe', 0.3)),
                'omega': avg_metrics.get('omega_ratio', avg_metrics.get('omega', 1.1)),
                'volatility': avg_metrics.get('volatility', avg_metrics.get('vol', 0.15)),
                'drawdown': avg_metrics.get('max_drawdown', avg_metrics.get('drawdown', 0.08)),
                'win_rate': avg_metrics.get('win_rate', avg_metrics.get('win_ratio', 0.58)),
                'profit_factor': avg_metrics.get('profit_factor', 1.2),
                'total_return': avg_metrics.get('total_return', avg_metrics.get('return', 0.10)),
                'calmar': avg_metrics.get('calmar_ratio', avg_metrics.get('calmar', 0.7)),
                'sortino': avg_metrics.get('sortino_ratio', avg_metrics.get('sortino', 0.6))
            }
            
                
            return mapped_metrics
            
        except Exception as e:
            return None
        
    def analyze_formula(self):
        """Lance une analyse R√âELLE de la formule bas√©e sur les donn√©es CSV"""
        if not self.current_formula.strip():
            QMessageBox.warning(self, "Formule manquante", 
                              "Veuillez d'abord cr√©er une formule dans l'onglet Portfolio & Formules.")
            return
            
        # R√©cup√©rer les vraies m√©triques
        base_metrics = self._get_average_strategy_metrics()
        
        if not base_metrics:
            QMessageBox.warning(self, "Donn√©es manquantes", 
                              "Impossible d'analyser la formule sans strat√©gies CSV import√©es.")
            return
        
        # Calculer l'allocation avec les vraies m√©triques
        try:
            # Utiliser les m√©triques moyennes pour calculer l'allocation de base
            safe_dict = {
                'sqrt': np.sqrt,
                'abs': abs,
                'max': max,
                'min': min,
                'log': np.log,
                'exp': np.exp
            }
            
            formula_lower = self.current_formula.lower()
            for key, value in base_metrics.items():
                formula_lower = formula_lower.replace(key, str(value))
            
            base_allocation = eval(formula_lower, {"__builtins__": {}}, safe_dict)
            base_allocation = max(0, min(100, float(base_allocation)))
            
            # Analyser la structure de la formule
            variables_used = []
            for var in ['sharpe', 'omega', 'volatility', 'drawdown', 'win_rate', 'profit_factor', 'total_return', 'calmar', 'sortino']:
                if var in self.current_formula.lower():
                    variables_used.append(var)
            
            # Analyse qualitative bas√©e sur les vraies donn√©es
            results = f"""üìä ANALYSE R√âELLE DE LA FORMULE (BAS√âE SUR VOS DONN√âES CSV)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìê Formule analys√©e: {self.current_formula}
üíº Allocation calcul√©e avec vos donn√©es: {base_allocation:.2f}% par strat√©gie

üîç ANALYSE STRUCTURELLE:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Variables utilis√©es: {len(variables_used)} d√©tect√©es ({', '.join(variables_used)})
‚Ä¢ Complexit√©: {'Simple' if len(variables_used) <= 2 else 'Mod√©r√©e' if len(variables_used) <= 4 else 'Complexe'}
‚Ä¢ Type: {'Conservative' if base_allocation < 5 else 'Mod√©r√©e' if base_allocation < 15 else 'Agressive'}

üìä M√âTRIQUES DE BASE (VOS STRAT√âGIES CSV):
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Sharpe moyen: {base_metrics['sharpe']:.3f}
‚Ä¢ Omega moyen: {base_metrics['omega']:.3f}  
‚Ä¢ Volatilit√©: {base_metrics['volatility']*100:.1f}%
‚Ä¢ Drawdown: {base_metrics['drawdown']*100:.1f}%
‚Ä¢ Win Rate: {base_metrics['win_rate']*100:.1f}%

üéØ √âVALUATION R√âALISTE:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Allocation: {base_allocation:.2f}% = {'üü¢ PROFESSIONNELLE' if base_allocation < 5 else 'üü° ACCEPTABLE' if base_allocation < 15 else 'üî¥ DANGEREUSE'}
‚Ä¢ Risque estim√©: {'FAIBLE' if base_allocation < 5 else 'MOD√âR√â' if base_allocation < 15 else '√âLEV√â'}
‚Ä¢ Coh√©rence: {'‚úÖ COH√âRENTE' if 1 <= base_allocation <= 10 else '‚ö†Ô∏è V√âRIFIER LES PARAM√àTRES'}

üí° RECOMMANDATIONS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"""

            if base_allocation < 2:
                results += "\nüî¥ ALLOCATION TROP FAIBLE - Augmenter les coefficients ou revoir la formule"
            elif base_allocation > 20:
                results += "\nüî¥ ALLOCATION DANGEREUSE - R√©duire les coefficients ou ajouter plus de s√©curit√©"
            else:
                results += "\n‚úÖ ALLOCATION DANS UNE FOURCHETTE ACCEPTABLE"

            results += f"\n\n‚ö° Cette analyse utilise VOS VRAIES donn√©es CSV, pas de chiffres invent√©s !"
            results += f"\nüéØ Lancez Monte Carlo ou Stress Test pour des analyses plus pouss√©es."
            
        except Exception as e:
            results = f"""‚ùå ERREUR DANS L'ANALYSE DE LA FORMULE

Formule: {self.current_formula}
Erreur: {str(e)}

V√©rifiez que votre formule est valide.
Variables disponibles: sharpe, omega, volatility, drawdown, win_rate, 
profit_factor, total_return, calmar, sortino

Exemples valides:
‚Ä¢ sharpe * 5
‚Ä¢ omega / drawdown  
‚Ä¢ sqrt(sharpe * omega) / volatility"""

        self.results_area.setText(results)
        
    def on_analysis_complete(self, results):
        """G√®re la fin d'une analyse"""
        pass